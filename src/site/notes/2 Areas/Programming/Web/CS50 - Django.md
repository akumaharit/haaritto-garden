---
{"dg-publish":true,"permalink":"/2-areas/programming/web/cs-50-django/","tags":["cs50web","django"],"created":"2025-10-18T15:42:21.382+07:00","updated":"2025-10-25T15:31:24.447+07:00"}
---

Can be used to automatically generate HTML or CSS, enabling **dynamic web**
HTTP is just a protocol for how to message to be sent back and forth.
Django is a web framework

Request
```
GET / HTTP/1.1
Host: www.example.com
```
`GET` is  type of a request to GET a page
`HOST` is the url for trying to access the webpage

Response
```
HTTP/1.1 200 OK
Context-type: text/html
```
200 OK = Response code
Context-type = format of the data that is coming back from the request, and this one is "html"

### Creating Django Project
`django-admin startproject PROJECT_NAME` and it will create starter files for us.
- `manage.py` is the file that we're going to be used to execute commands
- `settings.py` contain important settings for Django project.
- `urls.py` like table of content for the website.
use `python manage.py runserver` is used to run command for 'running this webserver' and the Django project will be run
**Django project can consist of one or more Django application within it.**

### Creating Django Application
`python manage.py startapp APP_NAME` to create django app
django will created new directory called "hello" and inside will be generated by default, 
**the important one is** `views.py` is going to be a file that will describe what will be displayed when they visit a particular route, what gets rendered to the user.
After created the app, you have to **install it into the project** by openning `settings.py` of the project, find `INSTALLED_APPS` and add 'APP_NAME' into the list

### Creating a view
by convention we create the request like this
```python
from django.http import HttpResponse

def index(request): #request represent the HTTP request that the user made to the web server
	return HttpResponse("Hello, world!") #special class from Django, you have to import it to use it
```
Now to make this view work, we have to link it with the `urls.py`
Each app can have own `urls.py` or you could just use the project one.

### Creating urls.py for an app
begin with `from django.urls import path`
create a list `urlpatterns = []`  which will be allowable URLs that can be accessed for this particular apps.
```python
from django.urls import path
from . import views #from current directory import views -> which will import everything from views.py

urlpatterns = [ #creating a url
	path("", views.index, name="index") 
#empty string to mean no additional argument OR when someone visit just the DEFAULT route of this app
# second argument to tell what to be rendered. in this case it is views (as created in views.py) and .index for the view called "index"  that we have created. 
#name is used to provide name to represent this url pattern, make it easier to reference it from other part of application.
]

```
### urls.py for an project
there will be `urlpatterns` with already included the path to run `admin.site.urls` which is a default application called admin app
add `path('hello/', include("hello.urls"))` to add the link to the hello application, and include all the urls setting in that application, to use include you have to `from django.urls import include`
Now when you launch the django and go for /hello it will run the hello app -> index view
If you created another view in the hello app, and added the url in the app for the view (such as harit view) inside the app view then you can just /hello/harit
### ChatGPT Summarize
|**Concept**|**Description**|**Example / Analogy**|**How It Works (When Visiting)**|
|---|---|---|---|
|**Main Page (`home/`)**|A base URL pattern that represents the main section of your app. Defined in the **project’s `urls.py`** to point to the app.|Like a **building entrance** — leads into the “home” app.|When the user visits `/home/`, Django routes the request from project’s `urls.py` → `home/urls.py` → matching view (e.g. `home()` view).|
|**Subpage (`home/subpage1`)**|A deeper route inside the same app, defined in the **app’s `urls.py`**. Each subpage has its own view function.|Like a **room inside the building** — still in the “home” app but serves a different purpose.|When visiting `/home/subpage1`, Django first matches `home/` in the project’s URLs, then looks inside `home/urls.py` for `path('subpage1/', ...)`.|
|**URL Structure**|URLs are matched hierarchically — from **project** → **app** → **subpage**.|Like following a **folder path**: `main folder → subfolder → file`.|Example: `http://127.0.0.1:8000/home/subpage1` → project routes `home/` → app routes `subpage1/`.|
|**View Function for Each Subpage**|Each subpage has its own function in `views.py`, returning its own content.|Each **room** has its own **guide** who gives specific info.|Example: `subpage1` → `def subpage1(request): return HttpResponse("Subpage 1 content")`.|
### Parameterizing the path via certain path converters
```python
#views.py
def greet(request,name):
	return HttpResponse(f"hello, {name}")

#urls.py
#inside url patterns, add 
path("<str:name>", views.greet, name="greet") 
```
`<str:name>` this route is telling that, this could be ANY string, and we will assign the string as `name` variable and pass that into `views.greet` function.

### Rendering HTML
`return render(request, "hello/index.html")` to render something, you have to pass in HTML request and the name of the **template**
Create a new folder called `templates` inside the app directory, and created `hello` (because the template name is `hello/index.html`)
We often prefix our templates with directory is to **namespace** them, to make sure no conflict happen if we have multiple index for multiple app

HTML can also be parameterize! 
In HTML, use double curly braces (Django templating language) `{{ name }}`
```python
from django.shortcuts import render

def greet(request, name):
	return render(request, "hello/greet.html", { #we add another argument to provide "context" for the template, it is a python dictionaryz
		"name": name.capitalize()
	})
```
To add logical statement you can use in HTML you can use `{% %}` -> the syntax is like python but not python! it also does not require indentation like python, but you can ident to make it easier to read
```html
{% if newyear %}
	<h1> YES </h1>
{% else %}
	<h1> NOW </h1>
{% endif %}

```

For loop is also supported
```html
{% for task in tasks %}
	<li>{{ task }}</li>
{% end for %}
```


### Static Files
For file such as CSS, in django we called that "static file" unlike the html template, we call that "dynamic file"
We store the static file just like the HTML template, however we will name the folder as "static" such as  `static/appname`
You can add `{% load static %}` to make it load static file into html template.
And then you could just `<link href="{% static 'newyear/styles.css' %}" rel="stylesheet">`
Django will just add the url by itself.


### Template Inheritance
So we don't have to copy pasting the HTML for each PAGE
Django have the ability of **template inheritance**
Start by creating a **layout** html, that the other html file are going to inherit from the layout.
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tasks</title>
</head>
<body>
    {% block body %}
    {% endblock %}
</body>
</html>

```
The rest of the structure won't change except "block body" might change,
**body** is the name of the block. You can change it to any that you wanted.
Now inside the index.html (or other html file that you want it to inherit the layout)
```html
{% extends "tasks/layout.html %}

{% block body %}
    <ul>
        {% for task in tasks %}
            <li>{{ task }}</li>
        {% empty %} 
            <li>No Tasks.</li>
        {% endfor %}
    </ul>
{% endblock %}
```
"Use the layout.html template" EXCEPT inside the block body, I would like to include all of this content
The `{% empty %}` will basically check if the loop is empty, and if it is empty then return this one. This is a nice feature of Django!

When linking between page in Django, you can use the path of the html relatively.
However, you can use the "name" of that "route" that use defined in the `url.py`
`<a href="{% url 'add' %}">Add a New Task</a>` instead of `<a href="tasks/add">Add a New Task</a>`

To prevent namespace collision it is a good practice to add
`app_name = "tasks"` in the urls.py, to easily identify what app_name is this urls.py file
and use **COLON** `<a href = "{% url 'tasks:index' %}">View Tasks</a>` to specify "tasks" app get the index URL

### Sending Data between app
Sending data between app, you can use the url for the `form`'s `action`
```html
    <h1>Add Task</h1>
    <form action ="{% url 'tasks:add' %}" method="post">
        <input type="text" name="task">
        <input type="submit">
    </form>
    <a href = "{% url 'index' %}">View Tasks</a>
```
Use **POST** if use are sending the data that can change the stat of the app -> no param in the URL !
CSRF -> Cross-Site Request Forgery
This token will be generated uniquely for each user and session, and the website will verify if the token is correct. This can prevent cross-site request forgery, by creating a request from another website that link to this website BUT it is not actually from the correct website. CSRF is enabled by default, as a django middielware. You can disable if it is not required.
You can generate a token by adding `{% csrf_token %}` in the form. It will be automatically generated and convert into `<input type ="hidden" name="csrfmiddlewaretoken" value="xxxxxxx">`

### Django Form
Inside the views.py for the application
You can also add a **client-side validation** to validate the data the user inputted, before being sent to the server.
```python
from django import forms
from django.shortcuts import render

class NewTaskForm(forms.Form):
	task = forms.CharField(label="New task")
	priority = forms.IntegerField(label="Priority", min_value = 1, max_value = 100)
	
def add(request):
	return render(request, "tasks/add.html", {
		"form": NewTaskForm() #render blank form
	})
```
Then inside the html, the django will the automaticalyl generate the form.
```html
{{ form }}
```
Regarding to the validation, it is a good practice to do **server-side validation** too
```python
from django.http import HttpResponseRedirect
from django.urls import reverse

def add(request):

    if request.method == "POST": #check if it is POST request
        form = NewTaskForm(request.POST) #will populate the form with the request post data
        if form.is_valid(): #this can be used to call if the data is valid
            task = form.cleaned_data["task"] #get access to the user submitted data and assign into the variable
            tasks.append(task)
            return HttpResponseRedirect(reverse("tasks:index")) #to redirect user to the http by reversing engineer of the route tasks:index
        else:
            return render(request, "tasks/add.html", { #if it error, then still return the same add.html page with the form and the submitted user data.
                "form": form #it will give me back the form and also the error
            })

    return render(request, "tasks/add.html",{
        "form": NewTaskForm() #render "blank" form
        
    })
```

## Django Session
```python
# Create your views here.
def index(request):
	if "tasks" not in request.session: # To check inside the session if there are already list of tasks in the sessions
		request.session["tasks"] = [] #If there isn't then create it
		
    return render(request, "tasks/index.html",{
        "tasks":request.session["tasks"]
    })
```
Django mostly want to store the data in the table including the sessions.
`python manage.py migrate` to create all of the default tables inside of Django's Database
To add something into the session list, use `request.session["tasks"] += [task]` 